const peggy = require('peggy'); // Assuming you have PEG.js installed
const { joiToPeg } = require('./joyutils');

function getStringColumns(columnTypes) {
    return Object.keys(columnTypes).filter(col => columnTypes[col] === 'STRING');
}

function getNumberColumns(columnTypes) {
    return Object.keys(columnTypes).filter(col => columnTypes[col] === 'INTEGER');
}

function getDecimalColumns(columnTypes) {
    return Object.keys(columnTypes).filter(col => columnTypes[col] === 'FLOAT' || columnTypes[col] === 'DECIMAL');
}

function getDateColumns(columnTypes) {
    return Object.keys(columnTypes).filter(col => columnTypes[col] === 'DATE');
}

function getJsonColumns(columnTypes) {
  return Object.keys(columnTypes).filter(col => columnTypes[col] === 'JSON');
}

function getBooleanColumns(columnTypes) {
    return Object.keys(columnTypes).filter(col => columnTypes[col] === 'BOOLEAN');
}



class CRUDParser {
    model = null;
    parser = null;

    genGrammar() {
        const totcolumns = Object.keys(this.model.rawAttributes);
        const columns = totcolumns.filter(item => !this.columnsToRemove.has(item));
        const columnTypes = {};
        columns.forEach(col => {
          columnTypes[col] = this.model.rawAttributes[col].type.key; 
        });

        const sc = getStringColumns(columnTypes);
        const nc = getNumberColumns(columnTypes);
        const dc = getDateColumns(columnTypes);
        const boolc = getBooleanColumns(columnTypes);
        const decc = getDecimalColumns(columnTypes);
        const jsonc = getJsonColumns(columnTypes);
        
        let  grammar = `
        Query
          = pairs:PairList {
              let obj = {};
              pairs.forEach(pair => {
                obj[pair[0]] = pair[1];
              });
              return obj;
          }
        
        PairList
          = head:Pair tail:("," Pair)* {
              return [head].concat(tail.map(t => t[1]));
          }
        
        Pair
        =`;
        const pairRules = [];
if (sc.length > 0) {
    pairRules.push(`column:StringColumn ":" value:StringValue { return [column, { value, type: "String" }]; }`);
}
if (nc.length > 0) {
    pairRules.push(`column:NumberColumn ":" value:NumberValue { return [column, { value, type: "Number" }]; }`);
}
if (dc.length > 0) {
    pairRules.push(`column:DateColumn ":" value:DateValue { return [column, { value, type: "Date" }]; }`);
}
if (boolc.length > 0) {
    pairRules.push(`column:BooleanColumn ":" value:BooleanValue { return [column, { value, type: "Boolean" }]; }`);
}
if (decc.length > 0) {
    pairRules.push(`column:DecimalColumn ":" value:DecimalValue { return [column, { value, type: "Decimal" }]; }`);
}
// Add rules for JSON columns
/*
if (jsonc.length > 0) {
  pairRules.push(`column:JsonColumn ":" value:JsonValue { return [column, { value, type: "Json" }]; }`);
}
  */
if (pairRules.length > 0) {
    grammar += pairRules.join("\n  / ");
} else {
    throw new Error("No columns are defined for this table. Cannot generate a valid grammar.");
}

// Define column and value rules conditionally
if (sc.length > 0) {
    grammar += `

StringColumn
  = ${sc.map(col => `"${col}"`).join(" / ")}

StringValue
  = '"' chars:[^"]* '"' {
      return chars.join("");
  }`;
}

if (nc.length > 0) {
    grammar += `
NumberColumn
  = ${nc.map(col => `"${col}"`).join(" / ")}

NumberValue
  = [0-9]+ {
      return parseInt(text(), 10);
  }`;
}

if (dc.length > 0) {
    grammar += `
DateColumn
  = ${dc.map(col => `"${col}"`).join(" / ")}

DateValue
  = day:[0-3]?[0-9] "/" month:[0-1]?[0-9] "/" year:[0-9][0-9][0-9][0-9] {
      return day.join("") + "/" + month.join("") + "/" + year.join("");
  }`;
}


if (decc.length > 0) {
    grammar += `
DecimalColumn
  = ${decc.map(col => `"${col}"`).join(" / ")}

DecimalValue
  = [0-9]+ ("." [0-9]+)? {
      return parseFloat(text());
  }`;
}

/*
if (jsonc.length > 0) {
  // Rule for the JSON column names
  grammar += `
JsonColumn
= ${jsonc.map(col => `"${col}"`).join(" / ")}

JsonValue
= `;

  // Iterate over each JSON column, get the Joi schema, and generate both column and value rules
  jsonc.forEach(col => {
      const joiSchema = this.model.jsonValidator[col] // Assuming schema is in validate.schema
      grammar += `
${col} = ${joiToPeg(joiSchema)}
`;
  });
}
*/
if (boolc.length > 0) {
    grammar += `
BooleanColumn
  = ${boolc.map(col => `"${col}"`).join(" / ")}

BooleanValue
  = "true" { return true; }
  / "false" { return false; }`;
}
            return grammar;
    }

    constructor(model, filterCols = []) {
        this.model = model;
        this.columnsToRemove =  new Set(['updatedAt', 'createdAt', 'active'].concat(filterCols));
        const grammar = this.genGrammar();
        // Compile the grammar
        this.parser = peggy.generate(grammar);
        logger.info("Parser initialized for model " + this.model.name);
    }

    parse(q , isActive = true) {
      const query = {
        start: parseInt(q.start || 1) - 1,
        limit: parseInt(q.limit || 100),
        order: q.order || 'ASC',
        orderBy: q.orderBy || 'id',
        sq: q.q || '',
        filter: { },
      };
      if (query.sq != "") {
        query.filter = this.parser.parse(query.sq);
      }
      query.filter.active = {value: isActive, type: "Boolean"};
      return query;
    }
}

module.exports = CRUDParser;